"""
MalwareBazaar API Data Source
Fetches recent malware samples from MalwareBazaar (abuse.ch).
"""

import logging
import requests
import os
from typing import List, Dict, Optional
from datetime import datetime
import time

logger = logging.getLogger(__name__)


class MalwareBazaarDataSource:
    """MalwareBazaar API integration for fresh malware samples."""

    API_URL = "https://mb-api.abuse.ch/api/v1/"

    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize MalwareBazaar data source.

        Args:
            api_key: MalwareBazaar API key (optional, but recommended for higher limits)
        """
        self.api_key = api_key or os.getenv("MALWAREBAZAAR_API_KEY", "")
        self.headers = {
            "Accept": "application/json",
            "API-KEY": self.api_key
        }

    def _make_request(self, endpoint: str, data: Dict) -> Optional[Dict]:
        """
        Make POST request to MalwareBazaar API.

        Args:
            endpoint: API endpoint
            data: Request payload

        Returns:
            JSON response or None on error
        """
        try:
            response = requests.post(
                f"{self.API_URL}{endpoint}",
                data=data,
                headers=self.headers,
                timeout=30
            )

            if response.status_code == 200:
                return response.json()
            else:
                logger.error(f"MalwareBazaar API error: {response.status_code}")
                return None

        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {e}")
            return None

    def get_recent_samples(self, limit: int = 100) -> List[Dict]:
        """
        Get recent malware samples.

        Args:
            limit: Maximum number of samples (max 1000)

        Returns:
            List of sample metadata
        """
        logger.info(f"Fetching {limit} recent samples from MalwareBazaar")

        data = {
            "query": "get_recent",
            "selector": limit
        }

        response = self._make_request("", data)

        if not response or response.get("query_status") != "ok":
            logger.error("Failed to fetch recent samples")
            return []

        samples = response.get("data", [])
        logger.info(f"Retrieved {len(samples)} samples")
        return samples

    def search_by_tag(self, tag: str, limit: int = 100) -> List[Dict]:
        """
        Search samples by tag.

        Args:
            tag: Tag to search (e.g., "python", "script", "ransomware")
            limit: Maximum number of results

        Returns:
            List of sample metadata
        """
        logger.info(f"Searching MalwareBazaar for tag: {tag}")

        data = {
            "query": "get_taginfo",
            "tag": tag,
            "limit": limit
        }

        response = self._make_request("", data)

        if not response or response.get("query_status") != "ok":
            logger.warning(f"No results for tag: {tag}")
            return []

        samples = response.get("data", [])
        logger.info(f"Found {len(samples)} samples for tag '{tag}'")
        return samples

    def download_sample(self, sha256_hash: str) -> Optional[bytes]:
        """
        Download malware sample by SHA256 hash.

        Args:
            sha256_hash: SHA256 hash of the sample

        Returns:
            Sample content as bytes or None
        """
        data = {
            "query": "get_file",
            "sha256_hash": sha256_hash
        }

        try:
            response = requests.post(
                f"{self.API_URL}",
                data=data,
                timeout=30
            )

            if response.status_code == 200:
                # Response is a ZIP file, we need to extract it
                import zipfile
                import io

                with zipfile.ZipFile(io.BytesIO(response.content)) as zf:
                    # Password is "infected" by default
                    for filename in zf.namelist():
                        return zf.read(filename, pwd=b"infected")

            return None

        except Exception as e:
            logger.error(f"Failed to download sample {sha256_hash}: {e}")
            return None

    def get_sample_info(self, sha256_hash: str) -> Optional[Dict]:
        """
        Get detailed information about a sample.

        Args:
            sha256_hash: SHA256 hash of the sample

        Returns:
            Sample metadata or None
        """
        data = {
            "query": "get_info",
            "hash": sha256_hash
        }

        response = self._make_request("", data)

        if not response or response.get("query_status") != "ok":
            return None

        return response.get("data", [{}])[0] if response.get("data") else None

    def fetch_malicious_samples(
        self,
        tags: Optional[List[str]] = None,
        max_samples: int = 100
    ) -> List[Dict]:
        """
        Fetch malicious script samples from MalwareBazaar.

        Args:
            tags: List of tags to search (e.g., ["python", "script"])
            max_samples: Maximum total samples to fetch

        Returns:
            List of samples with content and metadata
        """
        if tags is None:
            tags = [
                "python",
                "script",
                "ransomware",
                "backdoor",
                "stealer",
                "downloader"
            ]

        all_samples = []
        samples_per_tag = max(1, max_samples // len(tags))

        for tag in tags:
            logger.info(f"Fetching samples for tag: {tag}")
            samples_metadata = self.search_by_tag(tag, limit=samples_per_tag)

            for sample_meta in samples_metadata:
                # Filter for script-like files
                file_name = sample_meta.get("file_name", "").lower()
                file_type = sample_meta.get("file_type", "").lower()

                # Only process if it looks like a script
                if not any(ext in file_name for ext in [".py", ".ps1", ".sh", ".bat", ".vbs", ".js"]):
                    continue

                sha256 = sample_meta.get("sha256_hash")
                if not sha256:
                    continue

                # Try to download sample content
                content_bytes = self.download_sample(sha256)
                if not content_bytes:
                    logger.warning(f"Could not download sample: {sha256}")
                    continue

                # Try to decode as text
                try:
                    content = content_bytes.decode("utf-8", errors="ignore")
                    if len(content) < 50:  # Skip very small files
                        continue

                    all_samples.append({
                        "content": content,
                        "label": "malicious",
                        "source": "malwarebazaar",
                        "url": f"https://bazaar.abuse.ch/sample/{sha256}/",
                        "metadata": {
                            "sha256": sha256,
                            "file_name": sample_meta.get("file_name"),
                            "file_type": file_type,
                            "signature": sample_meta.get("signature"),
                            "tags": sample_meta.get("tags", []),
                            "first_seen": sample_meta.get("first_seen"),
                            "fetched_at": datetime.now().isoformat()
                        }
                    })

                except UnicodeDecodeError:
                    logger.warning(f"Could not decode sample as text: {sha256}")
                    continue

                # Rate limiting
                time.sleep(1)

                if len(all_samples) >= max_samples:
                    break

            if len(all_samples) >= max_samples:
                break

            # Rate limiting between tags
            time.sleep(2)

        logger.info(f"Fetched {len(all_samples)} malicious samples from MalwareBazaar")
        return all_samples
